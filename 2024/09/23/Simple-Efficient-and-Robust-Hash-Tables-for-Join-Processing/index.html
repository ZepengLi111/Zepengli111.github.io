<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Simple, Efficient, and Robust Hash Tables for Join Processing | 小大人</title><meta name="keywords" content="论文阅读"><meta name="author" content="lvzhipin,1224060318@qq.com"><meta name="copyright" content="lvzhipin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Simple, Efficient, and Robust Hash Tables for Join Processing"><meta name="application-name" content="Simple, Efficient, and Robust Hash Tables for Join Processing"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Simple, Efficient, and Robust Hash Tables for Join Processing"><meta property="og:url" content="http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/index.html"><meta property="og:site_name" content="小大人"><meta property="og:description" content="论文阅读：Simple, Efficient, and Robust Hash Tables for Join Processing主要贡献：设计了一个新的哈希表：unchained in-memory hash table。 Abstract哈希连接在关系数据处理过程起到了关键作用，并且他们的性能"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/avator.jpg"><meta property="article:author" content="lvzhipin"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/avator.jpg"><meta name="description" content="论文阅读：Simple, Efficient, and Robust Hash Tables for Join Processing主要贡献：设计了一个新的哈希表：unchained in-memory hash table。 Abstract哈希连接在关系数据处理过程起到了关键作用，并且他们的性能"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: lvzhipin","link":"链接: ","source":"来源: 小大人","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小大人',
  title: 'Simple, Efficient, and Robust Hash Tables for Join Processing',
  postAI: '',
  pageFillDescription: '论文阅读：Simple Efficient and Robust Hash Tables for Join Processing, Abstract, Introduction, Design Criteria, Joins are asymmetric, Joins are selective, Joins must be scalable, Joins can have duplicates, Approach, 3.1 Layout, 3.3 Parallel Build, 3.3.1 Tuple Collection, 3.3.2 Tuple Counting, 3.3.3 Copies, 3.4 Handling Large Tuple Sizes, 3.5 Large Memory Allocation, Evaluation, 总结：, 文章要解决的问题（背景）, 文章的贡献, 非链式, 优点, 缺点, 布隆过滤器, 特点, 哈希函数, 分区构建, 评估, 总结论文阅读主要贡献设计了一个新的哈希表哈希连接在关系数据处理过程起到了关键作用并且他们的性能对于整个数据库的性能也起到了关键作用由于中间结果难以预测理想的哈希连接实现方式必须兼顾对典型查询快速和不寻常数据分布的鲁棒性这篇论文中我们实现了一个简单但高效的非链内存哈希表设计它组合了构建侧分区邻接数组布局流水线探测布隆过滤器以及软件写组合缓冲区等一系列技术实现了在倾斜多对多连接时的性能提升同时在处理一对多连接时仍能保持顶级性能我们的哈希表的性能在关系查询中比开放寻址提升了倍在图处理查询中比开放寻址和拉链法提升了倍关系数据库依赖哈希连接有效处理查询而大多数查询的运行时间由过程决定底层哈希表有巨大的设计空间有相当多的研究聚焦于分区并行化以及倾斜处理下面我们制定了一个高效哈希表的实现目标高效使用内存和缓存高效执行指令高度可扩展的并行执行对各种数据分布具有鲁棒性这些标准经常相互冲突比如通过调整哈希表的负载因子可以使用内存换取周期或者可以优化数据放置其代价是复杂的锁定技术这篇文章中设计了一个内存哈希表在多对多以及经典的一对多连接哈希表没有最优的设计所有设计都是在不同标准下的权衡我们根据在许多基准测试和现实工作负载中发现的连接查询所做的观察来设计下面是一些观察连接是不对称的可能有小规模的和大规模的端连接是选择性的可能有许多在哈希表中没有发现匹配项连接是可扩展的因为输入可能很大内核是丰富的连接可能有重复因为元组可能有相同的这些观察指导了我们的设计选择我们的哈希表结合了构建侧分区邻接数组布局流水线探测过滤器和软件写组合缓冲区技术以实现高性能许多连接是不对称的哈希连接可以通过在小端在大端利用该不对称性由于端的大小通常会相差几个数量级因此阶段必须保持非常高效沿着这些思路我们可以在端花费更多的周期下面的一些设计利用了这些不对称性第三节会详细说明哈希表大小是的幂以增加内存消耗为代价使用单个移位指令计算索引构建端被完全物化分区和复制而探测端避免了物化并且将元组推入下面算子元组存储在一个紧凑的邻接数组中使得迭代匹配效率很高许多探测端元组可能没有匹配项有效消除探测端中没有匹配项的元组是很重要的布隆过滤器对于该任务是理想的构建开销最小高吞吐率好的选择性在节我们提出了优化的以最小化查询次数并且可以在没有空间开销的情况下嵌入哈希表另一个重要的方面是哈希函数哈希连接必须权衡计算哈希值的成本和哈希值的良好分布快速哈希函数容易造成倾斜而通用哈希函数的计算通常非常昂贵在节我们讨论了一个以指令为基础的低计算开销并且分布良好的哈希函数虽然哈希连接的构建端通常很小并且适合缓存但它仍然可以增长很大并且构建成本高此外最近的硬件趋势导致核心数量的增加因此并行化哈希表的构建对于利用现代硬件至关重要大多数通用哈希表不支持高效的并行构建因为它们依赖于限制可扩展性的锁以及随着插入更多元组调整哈希表的大小该过程在并行环境下具有挑战性如第节所述可以通过多阶段构建过程来避免这些问题构建端具有相同键对于开放寻址法影响很明显其中重复项按顺序存储与哈希表的其他条目相冲突而链接法的哈希表在这方面更加稳健因为他们限制了重复条目对于目录中一个槽的影响链接允许使用嵌入式过滤器进行有效的探针并且易于并行构建然而对于具有重复项的工作负载长链会降低性能因为它们无法有效地扫描这降低了偏斜的鲁棒性在第节中我们讨论了我们的它允许对重复元组进行有效的迭代我们现在描述哈希表的设计该设计遵循上一节中制定的目标以允许高效探针并行构建和对重复项的鲁棒性开放寻址法将所有元组存储在单个连续数组中这对于使用非选择性谓词和无重复键进行探测是有效的当连接具有选择性时开放寻址方案不能有效地过滤掉不匹配的元组当存在具有重复键的元组时这些元组与其他键相冲突从而导致高构建和探测成本相比之下链接哈希表构建一个与元组分开的目录目录条目指向共享相同哈希前缀的元组然后链接在链接列表中减少由于重复而导致的冲突但是链接列表遍历是昂贵的尤其是对于长链为了解决这些问题我们提出了它结合了开放寻址和链接的好处图说明了我们的哈希表的基本布局其中包含目录和元组存储作为链接的替代方案我们使用密集邻接数组进行碰撞解析元组存储在由其散列前缀排序的连续缓冲区中这样元组以与目录中的指针相同的方式存储邻接数组条目给出了拥有相同哈希前缀的元组范围并且我们可以执行顺序扫描来访问这些元组与链式哈希表相比消除了昂贵的指针跳转与开放寻址方案不同目录中的条目仅引用带有值的桶并且重复项不会传播到相邻条目我们测量了在我们的微基准测试中遍历链接列表的成本相比于数组如图所示遍历链接列表的成本比扫描邻接数组的成本增长得更快由于连接是选择性的所以重要的是有效地和更早地消除没有连接伙伴的元组我们在目录中的每个槽中嵌入寄存器阻塞的过滤器以概率性地丢弃最终没有连接伙伴的元组由于当前系统仅使用较低个地址空间字节因此指针的前位未使用我们可以使用这些存储过滤器我们将指针存储在上位将过滤器存储在下位在访问元组存储之前检查过滤器也可以推入其他操作符作为半连接约简器探测哈希表通常是连接执行中最昂贵的部分探测端可以比构建端大几个数量级因此优化哈希表查找和最小化每元组工作是至关重要的在下文中我们描述了我们对哈希表的高效探测图总结了探索哈希表中的元组的逻辑我们优化了哈希函数和哈希表的布局等几个方面来实现这一点因此过滤不匹配的元组只需要几个指令由于连接选择性连接处理期间的热测试路径正在过滤掉找不到连接伙伴的元组对于过滤我们使用具有位的寄存器阻塞过滤器为了实现低误报率我们为槽中的每个元组设置了位这使我们能够丢弃未设置过滤器中任何相应位的探测元组我们的实现预先一次性计算所有可能的标签位中置位在不成熟的实现中计算这个标签需要几十个指令来计算位的位置可能多个哈希函数为了在热路径中避免这些我们改为使用预先计算的查找表该查找表存储个不同的位模式并将它们加载到单个指令中请注意我们将此查找表使用均匀采样填充为个条目以便能够使用单个移位指令计算索引为了测试所有都设置在过滤器中我们对过滤器进行按位取反并与标签进行按位与这也可以充当空指针检查并转换为高效指令即在上转化为单个因此过滤元组的热路径仅包含五个指令和一个分支图显示了检查的逻辑与动态计算标签相比使用预先计算的查找表有几个理想的优势预计算标签只需要内存最多消耗个条目因此加载标签几乎与动态计算单个位标签一样便宜此外位标签误报率更低对于单个哈希误报率为而不是具有单个位标签的我们在图中分别使用和不使用过滤器评估了探针性能我们发现对于非选择性连接过滤器的开销很低对于选择性连接则非常有效每个标签的位数影响误报率如果使用的位过少则标签的数量就很少从而导致不同哈希值分配给相同的标签如果使用过多的位不同标签之间的相互影响会更严重这两种情况都会增加假阳性率因此给定哈希表的负载因子我们可以确定标签的最佳位数图显示了不同位数的误报率我们的哈希表负载因子为每个元组比特个标签是最优的假阳性率为带有个标签的填充查找表的假阳性率略高为与探测相比从输入键生成分布良好的哈希值需要大量的计算例如使用雪崩混合它本身包含的指令比我们的探测逻辑要多对于字节键完整的哈希大约需要倍的过滤器指令我们专门设计了为哈希字节或字节整数键的常见情况的函数如图所示为了减少目录槽中的冲突我们需要一个分布良好的哈希函数为了有效地计算哈希我们使用指令如图所示对于位输入我们使用一条指令和一个带有混合常数的乘法对于位输入我们需要两个指令因为每个摘要只有位生成的专用哈希函数允许对哈希表中的元组进行有效的过滤并且在将值从基表加载到过滤器检查之间只需要大约条指令然后我们可以通过迭代列表来生成所有匹配项在链接哈希表中这需要遍历一个链表并且需要对指针进行昂贵的依赖加载相反我们的从目录中的相邻槽确定冲突的范围从而允许在冲突列表上进行有效的迭代对于链式哈希表等人描述了一种并行高效构建哈希目录的方法然而我们提出的在邻接数组中重复存储的方法需要更多的同步我们通过分区来实现这一点在构建哈希表的第一步我们收集连接端的所有元组并对其进行哈希分区与等人的做法类似我们使用来存储初始元组从而保持它们在内存中的密度不过对于用作最终元组存储的邻接数组我们使用的是连续的内存块在最终存储中元组根据哈希值排序与目录中的单个条目相对应的所有元组都存储在一个连续的内存块中目录中的相邻条目按哈希值顺序指向相邻的元组块为了确定元组在最终存储中的分布情况我们会计算每个目录条目的元组数量然后将元组写入最终存储器同时更新目录在数据库查询的执行计划中哈希连接可能位于许多操作符之上这些操作符产生的数据被输入到中这些数据以元组流的形式从不同线程中产生元组的总量事先并不知晓对其的估计也可能不准确必须处理这种不确定性并能处理并发产生的不同数量的元组将其物化并在构建目录前对其进行哈希分区由于需要同时分配和物化许多元组因此通常会受到内存分配器的瓶颈制约为了避免这一瓶颈我们使用了它以大块的形式分配内存然后将这些大块的内存分配给单个元组这减少了系统调用的次数和全局内存分配器内的竞争在构建完成后一次性释放内存元组的分区使策略变得复杂因为我们希望同一分区内的元组在内存中大部分是连续的以便对单个分区内的元组进行高效迭代为此我们使用了三级第一层为每个线程以块为单位分配内存第二层为每个分区分配较小的块第三层从小块中分配单个元组其伪代码如图所示如果分区数量过多可能会产生昂贵的我们的多级分配方案避免了这一问题因为小块通常共享同一个内存页而在或大内存页的情况下共享的可能性更大这与软件写合并缓冲区的效果类似但不增加成本收集完所元组后需要在线程间交换分区这需要利用的内部结构来完成将内存块存储在一个链表中线程在处理分区之前会合并所有线程中与该分区相对应的内存块链表之后就能以单个分块列表的形式对元组进行高效迭代元组收集完成后我们需要构建目录并将元组最终复制到的紧凑元组存储区要将元组复制到最终位置我们首先需要确定共享相同哈希前缀的元组的存储范围这需要计算每个目录条目的元组数量然后使用排他性前缀和对目录的计数进行处理以确定元组的存储范围然后使用这些范围将元组复制到最终存储中的相应位置构建过程的最后一步是将元组复制到元组存储的最终位置计数后每个目录条目都包含共享相同哈希前缀的元组范围的起点当我们遍历元组时我们会将元组复制到起始位置然后递增起始指针最后每个目录条目都将指向相应范围的终点因此可以使用前一个条目的指针来确定起点此外一个特殊的目录项用于指向元组存储空间的最开始具体做法是首先为表分配一个额外的空间将第一个条目设置为元组存储空间的起点然后将指向目录的指针向前移动一个条目使用特殊条目可以避免探测时可能出现的分支计数和复制的伪代码如图所示只要元组足够小可以放入高速缓存行复制元组的成本就相对较低请注意只需两条加载指令和存储指令就能复制所有大小不超过向量宽度两倍的元组要做到这一点可以使用不大于元组大小的最大矢量宽度然后在元组的起点和终点各使用一条加载存储指令例如如果我们的元组是字节而的矢量宽度是字节那么我们的第一个加载存储对复制的是字节第二个加载存储对复制的是字节如果元组非常大我们需要另一种方法来提高构建效率在这种情况下我们会将元组链入一个链表而不是将它们复制到连续的存储空间这在一定程度上提高了构建过程的效率因为我们不需要复制元组不过我们必须更新元组中的链表指针由于内存写入放大包含指针的整个缓存行都会被写回内存不过对于大于一个高速缓存行的元组来说链接还是值得的将元组链接到目录条目是一个相对简单的操作如图所示目录条目指向上一个链接的元组而元组又指向上一个元组这样就建立了一个链接列表只需一个原子交换就能更新该条目指针只需一个就能更新标签这些操作可以通过原子对应操作实现线程安全由于原子变体的简单性可以避免初始分区阶段从而增加了目录构建过程中的竞争但降低了初始收集的成本在图中我们比较了在不同线程数下使用非链式哈希表与使用原子和无分区构建的链式哈希表所需的时间我们发现非链式构建几乎只需个线程就能达到峰值性能而链式构建则需要全部个超线程才能达到相同的性能水平在第节中我们讨论了元组收集的内存分配策略下面我们将讨论散列表本身的内存分配问题由于哈希表是一个大的连续内存块其内存管理基本上由一对和调用组成不过由于分配的块可能很大因此会出现许多微妙的问题在中系统调用用于向操作系统请求连续的虚拟内存块调用后虚拟内存尚未得到任何物理内存的支持当内存被访问时操作系统会按需懒散地分配物理内存页并用零填充不过如果对页面的首次访问是读取操作系统会将虚拟页面映射为只读的页面随后的任何写入操作都会触发新物理页面的分配虚拟页面也会重新映射到新页面由于与零页的原始映射可能缓存在不同内核的中因此操作系统必须进行销毁崩溃的成本非常高因为它需要操作系统发送处理器间中断为了避免代价高昂的崩溃对最近分配的页面进行的所有初始操作都应该是写操作例如链式哈希表在链接目录条目中的元组时应优先使用指令而不是对当释放内存时也会出现类似的问题因为同样需要销毁因此稍后异步执行操作有利于避免降低关键查询的速度由于是作为服务器数据库系统设计的因此它可以通过单个调用预先保留整个内存然后在内部进行管理从而避免这些问题在数据库关闭之前不会将内存交还给操作系统我们在微基准测试和关系数据库中实现了我们在一台拥有个内核个线程和内存的机器上运行了基准测试图图和图中的微基准测试使用的是哈希表每个哈希表有个大小为字节的元组此外我们还在关系基准和图基准和仅产生少于个结果元组的查询上使用所有硬件线程对进行了评估所有查询均重复次我们报告的是运行时间的中位数我们根据经验评估了哈希表的负载系数以及的相应误报率参见图在输入大小均匀分布的情况下我们的哈希表的负载率约为考虑到链长度的分布误报率为为了衡量非链式使用构建分区和链式不使用分区如和哈希表的相对性能我们执行了上述基准测试中的所有个查询并在图中报告了每个查询的非链式速度提升情况对于绝大多数查询两个哈希表的性能相似没有明显的加速或减速不过对于微小的查询链式散列表的运行时间最多可缩短因为表足够小可以放入缓存中进行探测分区的构建开销需要复制也就显而易见了相比之下对于大型查询非链式哈希表设计是有益的因为它避免了建表的原子指令并改善了探测的内存访问模式特别是在图形工作负载中对于运行时间超过毫秒的昂贵查询非链式设计最多可将性能提高倍对于这些查询哈希表包含更多具有重复键的元组链式设计导致每个元组都要进行一次随机内存访问因此成本很高解链技术通过在内存中连续存储元组解决了这一问题图左上角的两个图形查询和是具有巨大构建侧的查询其中单个分区无法放入缓存当单个分区无法放入低级缓存时就会大大降低元组的复制速度即图左下角的两个图查询是分区数过高导致构建侧很小的查询根本问题在于我们的实现在构建之初就设置了一次分区计数这个初始分区计数基于启发式方法如基数估计和线程数这些启发式方法并不完美可能会导致次优的分区计数未来我们计划探索自适应分区方案从较低的分区计数开始随着收集的元组增多而增加分区计数为了更好地展示分区收集和随后复制元组的单独影响我们在中实施了构建分区链我们在图中比较了有分区和无分区链式处理的性能我们可以看到分区通常会提高同一链中的元组在内存中更靠近的可能性从而改善局部性不过通过将元组复制到连续存储区来解链的效果更好我们在图中比较了未链化和链化与构建分区的性能我们发现可将图查询的性能最多提高倍接下来我们将测量哈希表在大型工作负载上的性能并将其与最先进的数据库系统进行比较我们使用和它们运行在一台较大的机器上该机器配备了两个个内核个线程和内存作为竞争对手我们选择了和这两个高性能分析查询引擎和使用查询编译使用矢量化所有系统都采用并行图显示了三种哈希表设计在基准测试和两个竞争对手测试中的性能我们发现我们的链式和非链式哈希表性能最佳比开放寻址哈希表平均快倍与开放寻址相比我们的高效探测和构造使这两种设计具有显著优势与其他系统相比比快倍比规模因子为的快倍同样我们的设计可以很好地扩展到更大的工作负载而且我们可以高效地并行构建表总结文章要解决的问题背景提升哈希连接的性能文章的贡献设计了一种新的非链式哈希表主要的特性如下一一列举非链式优点非链式相比于开放寻址法可以有效降低重复键带来的冲突影响非链式采用重复键带来的影响会被限制在同一个内以及可以有效过滤当连接具有强烈的选择性时可以在中嵌入一个布隆过滤器进行简单过滤非链式相比于链式哈希表在顺序扫描某个时消除了昂贵的指针跳转文章中说非链式结合了两种方式的优势缺点非链式相比于链式虽然可以规避时的指针跳转但是也增加了时的复制开销这对于很大时非常不友好不过文章中提到了此时可以使用链表同时非链式额外添加的布隆过滤器会带来新的开销如果选择性比较弱布隆过滤器可能作用很小布隆过滤器特点布隆过滤器放置在不会被使用的高位地址中这降低了其内存开销每个元组有位的位中置位这是实验验证的对应负载因子下的最优位数预先一次性计算所有可能的标签共种将其均匀采样填充为个条目预先计算并加载到内存中这样在计算和判断是否在过滤器中时就少了计算步骤而是直接从数组中取出即可降低了计算开销哈希函数简单哈希函数分布比较差复杂哈希函数计算成本高使用指令写了一个对位输入和位输入的专用哈希函数分区构建并行构建哈希表时使用分区收集进行收集对于每个线程来说对其收集到的数据进行分区然后放到分区块中第一次复制然后所有线程收集完成后在处理分区前会合并所有线程中与该分区相对应的内存块链表之后以分块列表的形式可以对元组进行高效迭代统计中的元组数量以及复制到最终位置分区的意义在于有利于统计和第二次复制时迭代高效至于为什么不只用一次复制并行构建哈希表可能是因为需要先收集所有元组进行统计每个中的元组数量才能进行最终位置的复制评估非链式相对于链式只在大型查询图查询时性能更好对于微小的查询甚至链式会更优对于有分区和无分区元组收集的链式有分区仍然可将图查询性能提高总体来说无论是链式还是非链式作者设计的哈希表都比和性能好很多但是性能好的原因到底是什么不一定是文章中描述的非链式带来的优势非链式只比链式好了一点可能是其他设计带来的优势可能需要看一下这篇文章总结这篇文章描述了很多想法和技术有些很有想象力比优势在于复杂查询图查询的性能提升巨大',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-23 22:00:14',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avator.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">小大人</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=863585550&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E5%BD%93%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.05rem;">当代人工智能<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">数据科学与工程算法基础<sup>1</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/" style="font-size: 1.05rem;">论文复现<sup>1</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" style="font-size: 1.05rem;">论文阅读<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF/" itemprop="url">大学生涯</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>论文阅读</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Simple, Efficient, and Robust Hash Tables for Join Processing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-23T13:55:39.000Z" title="发表于 2024-09-23 21:55:39">2024-09-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-09-23T14:00:14.907Z" title="更新于 2024-09-23 22:00:14">2024-09-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/"><header><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF/" itemprop="url">大学生涯</a><a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" tabindex="-1" itemprop="url">论文阅读</a><h1 id="CrawlerTitle" itemprop="name headline">Simple, Efficient, and Robust Hash Tables for Join Processing</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">lvzhipin</span><time itemprop="dateCreated datePublished" datetime="2024-09-23T13:55:39.000Z" title="发表于 2024-09-23 21:55:39">2024-09-23</time><time itemprop="dateCreated datePublished" datetime="2024-09-23T14:00:14.907Z" title="更新于 2024-09-23 22:00:14">2024-09-23</time></header><h1 id="论文阅读：Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing"><a href="#论文阅读：Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing" class="headerlink" title="论文阅读：Simple, Efficient, and Robust Hash Tables for Join Processing"></a>论文阅读：Simple, Efficient, and Robust Hash Tables for Join Processing</h1><p>主要贡献：设计了一个新的哈希表：unchained in-memory hash table。</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>哈希连接在关系数据处理过程起到了关键作用，并且他们的性能对于整个数据库的性能也起到了关键作用。由于中间结果难以预测，理想的哈希连接实现方式必须兼顾对典型查询快速和不寻常数据分布的鲁棒性。这篇论文中，我们实现了一个简单但高效的非链内存哈希表（unchained in-memory hash table design）设计。它组合了构建侧分区，邻接数组布局，流水线探测，布隆过滤器，以及软件写组合缓冲区等一系列技术，<u>实现了在倾斜多对多连接时的性能提升，同时在处理一对多连接时仍能保持顶级性能。我们的哈希表的性能在关系查询中比开放寻址提升了2倍，在图处理查询中比开放寻址和拉链法提升了20倍。</u></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>关系数据库依赖哈希连接有效处理join查询，而大多数查询的运行时间由join过程决定。底层哈希表有巨大的设计空间，有相当多的研究聚焦于分区、并行化以及倾斜处理。下面我们制定了一个高效哈希表的实现目标：</p>
<ul>
<li>高效使用内存和缓存</li>
<li>高效执行CPU指令</li>
<li>高度可扩展的并行执行</li>
<li>对各种数据分布具有鲁棒性</li>
</ul>
<p>这些标准经常相互冲突。比如通过调整哈希表的负载因子可以使用内存换取CPU周期。或者可以优化数据放置，其代价是复杂的锁定技术。这篇文章中设计了一个内存哈希表，在多对多以及经典的一对多连接。</p>
<p>哈希表没有最优的设计，所有设计都是在不同标准下的权衡。我们根据在许多基准测试和现实工作负载中发现的连接查询所做的观察来设计。下面是一些观察：</p>
<ul>
<li>连接是不对称的，可能有小规模的build和大规模的probe端。</li>
<li>连接是选择性的，可能有许多probe在哈希表中没有发现匹配项</li>
<li>连接是可扩展的，因为输入可能很大，CPU内核是丰富的</li>
<li>连接可能有重复，因为元组可能有相同的key。</li>
</ul>
<p>这些观察指导了我们的设计选择，我们的哈希表结合了<u>构建侧分区、邻接数组布局，流水线探测，Bloom过滤器和软件写组合缓冲区技术</u>，以实现高性能。</p>
<h2 id="Design-Criteria"><a href="#Design-Criteria" class="headerlink" title="Design Criteria"></a>Design Criteria</h2><h4 id="Joins-are-asymmetric"><a href="#Joins-are-asymmetric" class="headerlink" title="Joins are asymmetric"></a>Joins are asymmetric</h4><p>许多连接是不对称的。哈希连接可以通过在小端build，在大端probe利用该不对称性。由于端的大小通常会相差几个数量级，因此probe阶段必须保持非常高效。沿着这些思路，我们可以在build端花费更多的CPU周期。下面的一些设计利用了这些不对称性（第三节会详细说明）：</p>
<ul>
<li>哈希表大小是2的幂，以增加内存消耗为代价使用单个移位指令计算索引</li>
<li>构建端被完全物化、分区和复制。而探测端避免了物化，并且将元组推入下面算子</li>
<li>元组存储在一个紧凑的邻接数组中，使得迭代匹配效率很高</li>
</ul>
<h4 id="Joins-are-selective"><a href="#Joins-are-selective" class="headerlink" title="Joins are selective"></a>Joins are selective</h4><p>许多探测端元组可能没有匹配项。有效消除探测端中没有匹配项的元组是很重要的。布隆过滤器对于该任务是理想的：构建开销最小，高吞吐率，好的选择性。在3.2节，我们提出了优化的register-blocked Bloom filters以最小化查询次数，并且可以在没有空间开销的情况下嵌入哈希表。</p>
<p>另一个重要的方面是哈希函数。哈希连接必须权衡计算哈希值的成本和哈希值的良好分布。快速哈希函数容易造成倾斜，而通用哈希函数的计算通常非常昂贵。在3.2节，我们讨论了一个以crc32 CPU指令为基础的低计算开销并且分布良好的哈希函数。</p>
<h4 id="Joins-must-be-scalable"><a href="#Joins-must-be-scalable" class="headerlink" title="Joins must be scalable"></a>Joins must be scalable</h4><font style="color:rgb(29, 33, 41);">虽然哈希连接的构建端通常很小并且适合 CPU 缓存，但它仍然可以增长很大并且构建成本高。此外，最近的硬件趋势导致核心数量的增加；因此，并行化哈希表的构建对于利用现代硬件至关重要。大多数通用哈希表不支持高效的并行构建，因为它们 (1) 依赖于限制可扩展性的锁，以及 (2) 随着插入更多元组，调整哈希表的大小（该过程在并行环境下具有挑战性）。如第 3.3 节所述，可以通过多阶段构建过程来避免这些问题。</font>

<h4 id="Joins-can-have-duplicates"><a href="#Joins-can-have-duplicates" class="headerlink" title="Joins can have duplicates"></a>Joins can have duplicates</h4><p>构建端具有相同键对于开放寻址法影响很明显，<font style="color:rgb(29, 33, 41);">其中重复项按顺序存储，与哈希表的其他条目相冲突。而链接法的哈希表在这方面更加稳健，因为他们限制了重复条目对于目录中一个槽的影响。</font></p>
<font style="color:rgb(29, 33, 41);"> 链接允许使用嵌入式Bloom过滤器进行有效的探针，并且易于并行构建。然而，对于具有重复项的工作负载，长链会降低性能，因为它们无法有效地扫描，这降低了偏斜的鲁棒性。在第 3.1 节中，我们讨论了我们的unchained table，它允许对重复元组进行有效的迭代。</font>

<p><img src="/img/1726813770996-2a2f0f75-e393-4d45-a5ba-26cd8fd05cd6.png" alt=""></p>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><font style="color:rgb(29, 33, 41);">我们现在描述哈希表的设计。该设计遵循上一节中制定的目标，以允许高效探针、并行构建和对重复项的鲁棒性。</font>

<h4 id="3-1-Layout"><a href="#3-1-Layout" class="headerlink" title="3.1 Layout"></a>3.1 Layout</h4><font style="color:rgb(29, 33, 41);">开放寻址法将所有元组存储在单个连续数组中，这对于使用非选择性谓词和无重复键进行探测是有效的。当连接具有选择性时，开放寻址方案不能有效地过滤掉不匹配的元组。当存在具有重复键的元组时，这些元组与其他键相冲突，从而导致高构建和探测成本。相比之下，链接哈希表构建一个与元组分开的目录。目录条目指向共享相同哈希前缀的元组，然后链接在链接列表中，减少由于重复而导致的冲突。但是，链接列表遍历是昂贵的，尤其是对于长链。为了解决这些问题，我们提出了unchained hash table layout，它结合了开放寻址和链接的好处。</font>

<p><img src="/img/1726897458582-da68abac-ca41-4946-8817-c1bbf4da4fca.png" alt=""></p>
<font style="color:rgb(29, 33, 41);">图 2 说明了我们的哈希表的基本布局，其中包含目录和元组存储。作为链接的替代方案，我们使用密集邻接数组进行碰撞解析：元组存储在由其散列前缀排序的连续缓冲区中。这样，元组以与目录中的指针相同的方式存储。</font>邻接数组条目给出了拥有相同哈希前缀的元组范围，并且我们可以执行顺序扫描来访问这些元组。与链式哈希表相比，<u>unchained消除了昂贵的指针跳转</u>。与开放寻址方案不同，<u>目录中的条目仅引用带有值的桶，并且重复项不会传播到相邻条目</u>。我们测量了在我们的微基准测试中遍历链接列表的成本，相比于数组，如图3所示。遍历链接列表的成本比扫描邻接数组的成本增长得更快。

![](/img/1726897895121-c86c6795-9013-4ac4-ba8b-dacb838c019d.png)

由于连接是选择性的，所以重要的是有效地和更早地消除没有连接伙伴的元组。我们在目录中的每个槽中嵌入寄存器阻塞的 Bloom 过滤器，以概率性地丢弃最终没有连接伙伴的元组。由于当前系统仅使用较低 248 个地址空间字节，因此指针的前 16 位未使用，我们可以使用这些存储过滤器。我们将指针存储在上位，将过滤器存储在下位。在访问元组存储之前检查Bloom过滤器，也可以推入其他操作符作为半连接约简器。

#### 3.2 Efficient Probes

探测哈希表通常是连接执行中最昂贵的部分。探测端可以比构建端大几个数量级。因此，优化哈希表查找和最小化每元组工作是至关重要的。在下文中，我们描述了我们对unchained哈希表的高效探测。图 4 总结了探索哈希表中的元组的逻辑。我们优化了哈希函数、Bloom filter和哈希表的布局等几个方面来实现这一点。因此，过滤不匹配的元组只需要几个指令。

![](/img/1726899193851-8af677f2-4f4d-48eb-a831-1114178f8fee.png)

![](/img/1726899602731-236a5e26-c272-499c-9eab-32e0616bf91a.png)

由于连接选择性，连接处理期间的热测试路径正在过滤掉找不到连接伙伴的元组。对于过滤，我们使用具有 16 位 的寄存器阻塞 Bloom 过滤器。为了实现低误报率，我们为槽中的每个元组设置了 4 位，这使我们能够丢弃未设置过滤器中任何相应位的探测元组。

我们的实现预先一次性计算所有可能的标签（16位中置4位）。在不成熟的实现中，计算这个标签需要几十个指令来计算位的位置（可能多个哈希函数）。为了在热路径中避免这些，我们改为使用预先计算的查找表，该查找表存储$ 16 \choose 4 $ = 1820 个不同的位模式并将它们加载到单个指令中。请注意，我们将此查找表使用均匀采样填充为 2^11  = 2048 个条目，以便能够使用单个移位指令计算索引。为了测试所有都设置在 Bloom 过滤器中，我们对过滤器进行按位取反，并与标签进行按位与。这也可以充当空指针检查并转换为高效指令，即在 x86 上转化为单个 ANDN。因此，过滤元组的热路径仅包含五个指令和一个分支。图 6 显示了检查的逻辑。

与动态计算标签相比，使用预先计算的查找表有几个理想的优势：预计算标签只需要4KB内存，最多消耗1个TLB条目。因此，加载标签几乎与动态计算单个位标签一样便宜。此外，4 位标签误报率更低。对于单个哈希，误报率为 1/1820，而不是具有单个位标签的 1/16。我们在图 5 中分别使用和不使用过滤器评估了探针性能。我们发现，对于非选择性连接，Bloom 过滤器的开销很低，对于选择性连接则非常有效。

![](/img/1726903671955-fe6e4d0e-e46c-4144-8e8b-78d5b3ae169f.png)

每个标签的位数影响误报率。如果使用的位过少，则标签的数量就很少，从而导致不同哈希值分配给相同的标签。如果使用过多的位，不同标签之间的相互影响会更严重。这两种情况都会增加假阳性率。因此，给定哈希表的负载因子，我们可以确定标签的最佳位数。图7显示了不同位数的误报率。我们的哈希表负载因子为65%，每个元组4比特，1820个标签是最优的，假阳性率为1/169。带有2048个标签的填充查找表的假阳性率略高，为1/168。

![](/img/1726904107339-9f89646f-cd0f-46ef-b286-e5774817f818.png)

<font style="color:rgb(29, 33, 41);">与探测相比，从输入键生成分布良好的哈希值需要大量的计算。例如，xxh3使用雪崩混合，它本身包含的指令比我们的探测逻辑要多，对于8字节键，完整的xxh3哈希大约需要4倍的过滤器指令。我们专门设计了为哈希4字节或8字节整数键的常见情况的函数，如图8所示。</font>

<p><img src="/img/1726904456588-f523d49b-c4f6-48c4-af3b-e24a7ab99837.png" alt=""></p>
<font style="color:rgb(29, 33, 41);">为了减少目录槽中的冲突，我们需要一个分布良好的哈希函数。为了有效地计算哈希，我们使用CRC指令。如图8所示，对于32位输入，我们使用一条crc32指令和一个带有混合常数的乘法。对于64位输入，我们需要两个crc32指令，因为每个CRC摘要只有32位。生成的专用哈希函数允许对哈希表中的元组进行有效的过滤，并且在将值从基表加载到Bloom过滤器检查之间只需要大约10条指令。然后，我们可以通过迭代列表来生成所有匹配项。在链接哈希表中，这需要遍历一个链表，并且需要对next指针进行昂贵的依赖加载。相反，我们的unchained table从目录中的相邻槽确定冲突的范围，从而允许在冲突列表上进行有效的迭代。</font>

<h4 id="3-3-Parallel-Build"><a href="#3-3-Parallel-Build" class="headerlink" title="3.3 Parallel Build"></a>3.3 Parallel Build</h4><p>对于链式哈希表，Leis 等人描述了一种并行高效构建哈希目录的方法。然而，我们提出的在邻接数组中重复存储的方法需要更多的同步，我们通过分区来实现这一点。在构建哈希表的第一步，我们收集连接build端的所有元组，并对其进行哈希分区。与 Richter 等人的做法类似，我们使用slap allocator来存储初始元组，从而保持它们在内存中的密度。不过，对于用作最终元组存储的邻接数组，我们使用的是连续的内存块。在最终存储中，元组根据哈希值排序；与目录中的单个条目相对应的所有元组都存储在一个连续的内存块中，目录中的相邻条目按哈希值顺序指向相邻的元组块。为了确定元组在最终存储中的分布情况，我们会计算每个目录条目的元组数量。然后，将元组写入最终存储器，同时更新目录。</p>
<h5 id="3-3-1-Tuple-Collection"><a href="#3-3-1-Tuple-Collection" class="headerlink" title="3.3.1 Tuple Collection"></a>3.3.1 Tuple Collection</h5><p>在数据库查询的执行计划中，哈希连接可能位于许多操作符之上，这些操作符产生的数据被输入到join中。这些数据以元组流的形式从不同线程中产生。元组的总量事先并不知晓，对其的估计也可能不准确。Tuple Collection必须处理这种不确定性，并能处理并发产生的不同数量的元组，将其物化，并在构建目录前对其进行哈希分区。</p>
<p>由于需要同时分配和物化许多元组，因此tuple collection通常会受到内存分配器的瓶颈制约。为了避免这一瓶颈，我们使用了slab allocator，它以大块的形式分配内存，然后将这些大块的内存分配给单个元组。这减少了系统调用的次数和全局内存分配器内的竞争。在构建完成后一次性释放内存。</p>
<p>元组的分区使bump allocation策略变得复杂，因为我们希望同一分区内的元组在内存中大部分是连续的，以便对单个分区内的元组进行高效迭代。为此，我们使用了三级bump allocator。第一层为每个线程以块为单位分配内存，第二层为每个分区分配较小的块，第三层从小块中分配单个元组。其伪代码如图 9 所示。</p>
<p><img src="/img/1726909490500-c52df790-f410-45e9-8828-7cf8a3313197.png" alt=""></p>
<p>如果分区数量过多，tuple collection可能会产生昂贵的 TLB misses。我们的多级分配方案避免了这一问题，因为小块通常共享同一个内存页，而在 2 MB 或 1 GB 大内存页的情况下，共享的可能性更大。这与软件写合并缓冲区的效果类似，但不增加成本。</p>
<p>收集完所元组后，需要在线程间交换分区。这需要利用bump allocator的内部结构来完成。bump allocator将内存块存储在一个链表中。线程在处理分区之前，会合并所有线程中与该分区相对应的内存块链表。之后，就能以单个分块列表的形式对元组进行高效迭代。</p>
<h5 id="3-3-2-Tuple-Counting"><a href="#3-3-2-Tuple-Counting" class="headerlink" title="3.3.2 Tuple Counting"></a>3.3.2 Tuple Counting</h5><p>元组收集完成后，我们需要构建目录，并将元组最终复制到的紧凑元组存储区。要将元组复制到最终位置，我们首先需要确定共享相同哈希前缀的元组的存储范围。这需要计算每个目录条目的元组数量。然后使用 排他性前缀和 对目录的计数进行处理，以确定元组的存储范围。然后使用这些范围将元组复制到最终存储中的相应位置。</p>
<h5 id="3-3-3-Copies"><a href="#3-3-3-Copies" class="headerlink" title="3.3.3 Copies"></a>3.3.3 Copies</h5><p>构建过程的最后一步是将元组复制到元组存储的最终位置。计数后，每个目录条目都包含共享相同哈希前缀的元组范围的起点。当我们遍历元组时，我们会将元组复制到起始位置，然后递增起始指针。最后，每个目录条目都将指向相应范围的终点，因此可以使用前一个条目的指针来确定起点。此外，一个特殊的目录项 directory[-1]用于指向元组存储空间的最开始。具体做法是，<u>首先为表分配一个额外的空间，将第一个条目设置为元组存储空间的起点，然后将指向目录的指针向前移动一个条目</u>。使用特殊条目可以避免探测时可能出现的分支。计数和复制的伪代码如图 10 所示。</p>
<p><img src="/img/1726910415046-dbfa3a88-238e-45f6-84cc-2d50fe3b87e6.png" alt=""></p>
<h4 id="3-4-Handling-Large-Tuple-Sizes"><a href="#3-4-Handling-Large-Tuple-Sizes" class="headerlink" title="3.4 Handling Large Tuple Sizes"></a>3.4 Handling Large Tuple Sizes</h4><p>只要元组足够小，可以放入高速缓存行，复制元组的成本就相对较低。请注意，只需两条加载指令和存储指令，就能复制所有大小不超过 CPU 向量宽度两倍的元组。要做到这一点，可以使用不大于元组大小的最大矢量宽度，然后在元组的起点和终点各使用一条加载/存储指令。例如，如果我们的元组是 24 字节，而 CPU 的矢量宽度是 16 字节，那么我们的第一个加载/存储对复制的是 0-15 字节，第二个加载/存储对复制的是 8-23 字节。</p>
<p>如果元组非常大，我们需要另一种方法来提高构建效率。在这种情况下，我们会将元组链入一个链表，而不是将它们复制到连续的存储空间。这在一定程度上提高了构建过程的效率，因为我们不需要复制元组。不过，我们必须更新元组中的链表指针，<u>由于内存写入放大，包含指针的整个缓存行都会被写回内存</u>。不过，对于大于一个高速缓存行的元组来说，链接还是值得的。</p>
<p>将元组链接到目录条目是一个相对简单的操作，如图 11 所示。目录条目指向上一个链接的元组，而元组又指向上一个元组，这样就建立了一个链接列表。只需一个 xchg（原子交换） 就能更新该条目指针，只需一个 or 就能更新标签。这些操作可以通过原子对应操作实现线程安全。由于原子变体的简单性，可以避免初始分区阶段，从而增加了目录构建过程中的竞争，但降低了初始收集的成本。</p>
<p><img src="/img/1726939273828-b5fbe0e2-3e5c-4d42-be25-a28318223834.png" alt=""></p>
<p>在图 12 中，我们比较了在不同线程数下使用非链式哈希表与使用原子和无分区构建的链式哈希表所需的时间。我们发现，非链式构建几乎只需 8 个线程就能达到峰值性能，而链式构建则需要全部 32 个超线程才能达到相同的性能水平。</p>
<p><img src="/img/1726939324686-1eae1fe9-d051-4035-8456-0806d54c035b.png" alt=""></p>
<h4 id="3-5-Large-Memory-Allocation"><a href="#3-5-Large-Memory-Allocation" class="headerlink" title="3.5 Large Memory Allocation"></a>3.5 Large Memory Allocation</h4><p>在第 3.3.1 节中，我们讨论了元组收集的内存分配策略。下面，我们将讨论散列表本身的内存分配问题。由于哈希表是一个大的连续内存块，其内存管理基本上由一对 malloc 和 free 调用组成。不过，由于分配的块可能很大，因此会出现许多微妙的问题。</p>
<p>在 Linux 中，mmap 系统调用用于向操作系统请求连续的虚拟内存块。调用 mmapcall 后，虚拟内存尚未得到任何物理内存的支持。当内存被访问时，操作系统会按需懒散地分配物理内存页，并用零填充。不过，如果对页面的首次访问是读取，操作系统会将虚拟页面映射为只读的 0 页面。随后的任何写入操作都会触发新物理页面的分配，虚拟页面也会重新映射到新页面。由于与零页的原始映射可能缓存在不同 CPU 内核的 TLB 中，因此操作系统必须进行 TLB 销毁。TLB 崩溃的成本非常高，因为它需要操作系统发送处理器间中断。为了避免代价高昂的 TLB 崩溃，对最近分配的页面进行的所有初始操作都应该是写操作。例如，链式哈希表在链接目录条目中的元组时，应优先使用 xchg 指令，而不是 load/cmpxch 对。</p>
<p>当释放内存时，也会出现类似的问题，因为 munmap 同样需要 TLB 销毁。因此，稍后异步执行 munmap 操作有利于避免降低关键查询的速度。由于 Umbra 是作为服务器数据库系统设计的，因此它可以通过单个 mmap 调用预先保留整个内存，然后在内部进行管理，从而避免这些问题。在数据库关闭之前，不会将内存交还给操作系统。</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>我们在微基准测试和关系数据库 Umbra 中实现了unchained table。我们在一台拥有 16 个内核、32 个线程和 64 GB 内存的 AMD Ryzen Zen3 5950X 机器上运行了基准测试。图 3、图 5 和图 12 中的微基准测试使用的是哈希表，每个哈希表有 720720 个大小为 32 字节的元组。此外，我们还在关系基准 TPC-H SF {1, 10}、TPC-DS SF {1, 10} 和 JOB [18 ]；图基准 LDBC SNB BI [27 ] SF 10 和 CE [7] （仅产生少于 109 个结果元组的查询）上使用所有硬件线程对 Umbra 进行了评估。所有查询均重复 10 次，我们报告的是运行时间的中位数。</p>
<p>我们根据经验评估了哈希表的负载系数以及 couldContain 的相应误报率（参见图 4）。在输入大小均匀分布的情况下，我们的哈希表的负载率约为 0.65，考虑到链长度的分布，误报率为 1/168。</p>
<p>为了衡量非链式（使用构建分区）和链式（不使用分区，如 Hyper  和 DuckDB ）哈希表的相对性能，我们执行了上述基准测试中的所有 10312 个查询，并在图 13 中报告了每个查询的非链式速度提升情况。<u>对于绝大多数查询，两个哈希表的性能相似，没有明显的加速或减速。不过，对于微小的查询，链式散列表的运行时间最多可缩短 30%，因为表足够小，可以放入缓存中进行探测，分区的构建开销（需要复制）也就显而易见了。</u>相比之下，<u>对于大型查询，非链式哈希表设计是有益的，因为它避免了建表的原子指令，并改善了探测的内存访问模式。特别是在图形工作负载中，对于运行时间超过 100 毫秒的昂贵查询，非链式设计最多可将性能提高 20 倍。对于这些查询，哈希表包含更多具有重复键的元组，链式设计导致每个元组都要进行一次随机内存访问，因此成本很高。</u>解链技术通过在内存中连续存储元组解决了这一问题。</p>
<p>图 13 左上角的两个图形查询（dblp_cyclic_q9_06 和 hetio_cyclic_q9_12）是具有巨大构建侧的查询，其中单个分区无法放入 L1 缓存。当单个分区无法放入低级缓存时，就会大大降低元组的复制速度。yago_acyclic_Star_6_{42, 43}，即图 13 左下角的两个图查询，是分区数过高导致构建侧很小的查询。根本问题在于，我们的实现在构建之初就设置了一次分区计数。这个初始分区计数基于启发式方法，如基数估计和线程数。这些启发式方法并不完美，可能会导致次优的分区计数。未来，我们计划探索自适应分区方案，从较低的分区计数开始，随着收集的元组增多而增加分区计数。</p>
<p><img src="/img/1726994058462-0e0c4646-4699-4f2c-ab81-630b59249504.png" alt=""></p>
<p>为了更好地展示分区收集和随后复制元组的单独影响，我们在 Umbra 中实施了构建分区链。我们在图 14 中比较了有分区和无分区链式处理的性能。我们可以看到，<u>分区通常会提高同一链中的元组在内存中更靠近的可能性</u>，从而改善局部性。不过，通过将元组复制到连续存储区来解链的效果更好。我们在图 15 中比较了未链化和链化与构建分区的性能。我们发现，unchained可将图查询的性能最多提高 10 倍。</p>
<p><img src="/img/1726994068595-af2247af-4514-4bd9-a142-49d450c3baab.png" alt=""></p>
<p><img src="/img/1727093008035-0d9929a0-ded8-42ff-8865-d4aec35c11ca.png" alt=""></p>
<p>接下来，我们将测量哈希表在大型工作负载上的性能，并将其与最先进的数据库系统进行比较。我们使用 TPC-H SF 100 和 1000，它们运行在一台较大的机器上，该机器配备了两个 AMD EPYC 7713 CPU（128 个内核、256 个线程和 256 GB 内存）。作为竞争对手，我们选择了 Hyper v0.0.18825 [ 13 ] 和 DuckDB v0.10.1 [ 23 ] 这两个高性能分析查询引擎。Hyper 和 Umbra 使用查询编译，DuckDB 使用矢量化[ 5 ]。所有系统都采用 morsel-driven 并行[17]。</p>
<font style="color:rgb(29, 33, 41);">图 16 显示了三种哈希表设计在 TPC-H 基准测试和两个竞争对手测试中的性能。我们发现，我们的链式和非链式哈希表性能最佳，比 Robin Hood 开放寻址哈希表平均快 2 倍。与开放寻址相比，我们的高效探测和构造使这两种设计具有显著优势。与其他系统相比，Umbra 比 Hyper 快 2 倍，比规模因子为 100 的 DuckDB 快 6 倍。同样，我们的设计可以很好地扩展到更大的工作负载，而且我们可以高效地并行构建表。</font>

<p><img src="/img/1726994470100-224f8282-5815-4e63-ba2b-88c9d625b188.png" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h4 id="文章要解决的问题（背景）"><a href="#文章要解决的问题（背景）" class="headerlink" title="文章要解决的问题（背景）"></a>文章要解决的问题（背景）</h4><p>提升哈希连接的性能</p>
<h4 id="文章的贡献"><a href="#文章的贡献" class="headerlink" title="文章的贡献"></a>文章的贡献</h4><p>设计了一种新的非链式哈希表，主要的特性如下一一列举。</p>
<h5 id="非链式"><a href="#非链式" class="headerlink" title="非链式"></a>非链式</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>非链式相比于开放寻址法，可以有效降低重复键带来的冲突影响（非链式采用bucket，重复键带来的影响会被限制在同一个bucket内），以及可以有效过滤（当连接具有强烈的选择性时，可以在bucket中嵌入一个布隆过滤器，进行简单过滤）。</p>
<p>非链式相比于链式哈希表，在顺序扫描某个bucket时，消除了昂贵的指针跳转。</p>
<p>文章中说，非链式结合了两种方式的优势</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>非链式相比于链式，虽然可以规避probe时的指针跳转，但是也增加了build时的复制开销。这对于tuple很大时非常不友好，不过文章中提到了此时可以使用链表。</p>
<p>同时，非链式额外添加的布隆过滤器会带来新的开销。如果选择性比较弱，布隆过滤器可能作用很小。</p>
<h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>布隆过滤器放置在不会被使用的高16位地址中，这降低了其内存开销。</p>
<p>每个元组有4位的tag（16位中置4位，这是实验验证的对应负载因子下的最优位数）。</p>
<p>预先一次性计算所有可能的标签，共$ 16 \choose 4 $ = 1820 种，将其均匀采样填充为 2 ^ 11 = 2048个条目。预先计算并加载到内存中，这样在计算tag和判断tag是否在过滤器中时就少了计算步骤，而是直接从数组中取出即可，降低了计算开销。</p>
<h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>简单哈希函数分布比较差，复杂哈希函数计算成本高。使用CRC指令写了一个对32位输入和64位输入的专用哈希函数。</p>
<h5 id="分区构建"><a href="#分区构建" class="headerlink" title="分区构建"></a>分区构建</h5><p>并行构建哈希表时，使用分区收集进行收集。对于每个线程来说，对其收集到的数据进行分区，然后放到分区块中（第一次复制）。然后所有线程收集完成后，在处理分区前，会合并所有线程中与该分区相对应的内存块链表。之后，以分块列表的形式可以对元组进行高效迭代（统计directory中的元组数量以及复制到最终位置）。</p>
<p>分区的意义在于有利于统计和第二次复制时迭代高效。</p>
<p>至于为什么不只用一次复制并行构建哈希表，可能是因为需要先收集所有元组进行count（统计每个directory中的元组数量），才能进行最终位置的复制。</p>
<h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p>非链式相对于链式，只在大型查询（图查询）时性能更好，对于微小的查询甚至链式会更优。</p>
<p>对于有分区和无分区元组收集的链式，有分区仍然可将图查询性能提高。</p>
<p>总体来说，无论是链式还是非链式，作者设计的哈希表都比DuckDB和Hyper性能好很多。但是性能好的原因到底是什么？不一定是文章中描述的非链式带来的优势（非链式只比链式好了一点）。可能是其他设计带来的优势（Umbra？可能需要看一下这篇文章）？</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章描述了很多想法和技术，有些很有想象力。unchained比chained优势在于复杂查询（图查询）的性能提升巨大。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="/img/avator.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="/img/avator.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">lvzhipin</div><div class="post-copyright__author_desc">一蓑烟雨任平生</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/')">Simple, Efficient, and Robust Hash Tables for Join Processing</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Simple, Efficient, and Robust Hash Tables for Join Processing&amp;url=http://example.com/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小大人</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>论文阅读<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/avator.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/09/12/Extensible-Hash-Table-based-on-Hot-Ring/"><img class="prev-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Extensible Hash Table based on Hot Ring</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div>青春是一场有去无回的旅行，好的坏的都是风景。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">lvzhipin</h1><div class="author-info__desc">一蓑烟雨任平生</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ZepengLi111" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ASimple-Efficient-and-Robust-Hash-Tables-for-Join-Processing"><span class="toc-number">1.</span> <span class="toc-text">论文阅读：Simple, Efficient, and Robust Hash Tables for Join Processing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract"><span class="toc-number">1.1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Design-Criteria"><span class="toc-number">1.3.</span> <span class="toc-text">Design Criteria</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Joins-are-asymmetric"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">Joins are asymmetric</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Joins-are-selective"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">Joins are selective</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Joins-must-be-scalable"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">Joins must be scalable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Joins-can-have-duplicates"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">Joins can have duplicates</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Approach"><span class="toc-number">1.4.</span> <span class="toc-text">Approach</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Layout"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">3.1 Layout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Parallel-Build"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">3.3 Parallel Build</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-Tuple-Collection"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text">3.3.1 Tuple Collection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-Tuple-Counting"><span class="toc-number">1.4.0.2.2.</span> <span class="toc-text">3.3.2 Tuple Counting</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-Copies"><span class="toc-number">1.4.0.2.3.</span> <span class="toc-text">3.3.3 Copies</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Handling-Large-Tuple-Sizes"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">3.4 Handling Large Tuple Sizes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-Large-Memory-Allocation"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">3.5 Large Memory Allocation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluation"><span class="toc-number">1.5.</span> <span class="toc-text">Evaluation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E8%83%8C%E6%99%AF%EF%BC%89"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">文章要解决的问题（背景）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9A%84%E8%B4%A1%E7%8C%AE"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">文章的贡献</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E9%93%BE%E5%BC%8F"><span class="toc-number">1.6.0.2.1.</span> <span class="toc-text">非链式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.6.0.2.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.0.2.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.6.0.2.2.</span> <span class="toc-text">布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.0.2.2.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.0.2.3.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%9E%84%E5%BB%BA"><span class="toc-number">1.6.0.2.4.</span> <span class="toc-text">分区构建</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">评估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/Simple-Efficient-and-Robust-Hash-Tables-for-Join-Processing/" title="Simple, Efficient, and Robust Hash Tables for Join Processing">Simple, Efficient, and Robust Hash Tables for Join Processing</a><time datetime="2024-09-23T13:55:39.000Z" title="发表于 2024-09-23 21:55:39">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/Extensible-Hash-Table-based-on-Hot-Ring/" title="Extensible Hash Table based on Hot Ring">Extensible Hash Table based on Hot Ring</a><time datetime="2024-09-11T16:49:56.000Z" title="发表于 2024-09-12 00:49:56">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/04/Astar%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/" title="Astar算法题目">Astar算法题目</a><time datetime="2023-11-04T15:16:03.000Z" title="发表于 2023-11-04 23:16:03">2023-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/31/PCA%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/" title="PCA图像压缩">PCA图像压缩</a><time datetime="2023-10-31T06:38:10.000Z" title="发表于 2023-10-31 14:38:10">2023-10-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="lvzhipin" target="_blank">lvzhipin</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">1</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=863585550&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E5%BD%93%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 0.88rem;">当代人工智能<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">数据科学与工程算法基础<sup>1</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/" style="font-size: 0.88rem;">论文复现<sup>1</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" style="font-size: 0.88rem;">论文阅读<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="863585550" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=863585550&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("10/30/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 lvzhipin 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@lvzhipin.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>